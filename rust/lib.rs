#![forbid(
    unused_unsafe,
    unused_allocation,
    arithmetic_overflow,
    temporary_cstring_as_ptr
)]
#![doc = include_str!("README.md")]

/// This module contains Rust bindings generated by bindgen.
mod bindings {
    #![allow(warnings)]
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

/// String implementation with StringZilla C bindings under the hood.
pub struct String {
    inner: bindings::sz_string_view_t,
}

impl String {
    pub fn new(input: impl AsRef<str>) -> Self {
        let value = input.as_ref();
        String {
            inner: bindings::sz_string_view_t {
                start: value.as_ptr() as *const i8,
                length: value.as_bytes().len() as bindings::sz_size_t,
            },
        }
    }

    pub fn find(&self, start: usize, end: usize) -> Option<usize> {
        unimplemented!()
    }

    pub fn contains(&self, input: impl AsRef<str>, start: usize, end: usize) -> bool {
        unimplemented!()
    }

    pub fn split_lines(&self, keep_linebreaks: bool, separator: char) -> Vec<String> {
        unimplemented!()
    }

    pub fn split(&self, separator: char, max_split: usize, keep_separator: bool) -> Vec<String> {
        unimplemented!()
    }

    pub fn count(&self, input: impl AsRef<str>) -> usize {
        let value = input.as_ref();
        unsafe {
            bindings::sz_count_char(
                self.inner.start,
                self.inner.length,
                value.as_ptr() as *const i8,
            ) as usize
        }
    }
}

/// This function takes a raw pointer and converts its value to &str. Note that
/// this function should only be used for data which was originally initiated as
/// &str type.
const unsafe fn ptr_to_str<'a>(ptr: *const i8, len: usize) -> &'a str {
    let value = std::slice::from_raw_parts(ptr as *const u8, len);
    std::str::from_utf8_unchecked(value)
}

/// A macro for generating indexing implementations for [String].
macro_rules! impl_index_op__String {
    ($op_type:ty) => {
        impl ::std::ops::Index<$op_type> for String {
            type Output = str;

            #[inline]
            fn index(&self, index: $op_type) -> &Self::Output {
                let value = unsafe { ptr_to_str(self.inner.start, self.inner.length as usize) };
                &value[..][index]
            }
        }
    };
}

impl_index_op__String!(std::ops::Range<usize>);
impl_index_op__String!(std::ops::RangeTo<usize>);
impl_index_op__String!(std::ops::RangeFrom<usize>);
impl_index_op__String!(std::ops::RangeInclusive<usize>);

impl From<std::string::String> for String {
    #[inline]
    fn from(value: std::string::String) -> Self {
        String::new(value)
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn count() {
        let haystack = super::String::new("abba");
        assert_eq!(haystack.count("ab"), 1);
        assert_eq!(haystack.count("a"), 2);
        assert_eq!(haystack.count("b"), 2);
        assert_eq!(haystack.count("ba"), 1);
    }

    #[test]
    fn string_ops() {
        let haystack = super::String::new("abcdef");
        assert_eq!(&haystack[0..2], "ab");
        // assert_eq!(&haystack[2], "c");
        assert_eq!(&haystack[3..], "def");
        assert_eq!(&haystack[..2], "ab");
        assert_eq!(&haystack[0..=2], "abc");
    }
}
