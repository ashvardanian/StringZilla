name: "Pre-Release"

on:
  push:
    branches: ["main-dev"]
  pull_request:
    branches: ["main-dev"]

env:
  BUILD_TYPE: Release
  GH_TOKEN: ${{ secrets.SEMANTIC_RELEASE_TOKEN }}
  PYTHON_VERSION: 3.12
  SWIFT_VERSION: 6.0
  PYTHONUTF8: 1

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read

jobs:
  versioning:
    name: Update Version
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          persist-credentials: false
      - name: Run TinySemVer
        uses: ashvardanian/tinysemver@v2.1.1
        with:
          verbose: "true"
          version-file: "VERSION"
          update-version-in: |
            Cargo.toml:^version = "(\d+\.\d+\.\d+)"
            package.json:"version": "(\d+\.\d+\.\d+)"
            CMakeLists.txt:VERSION (\d+\.\d+\.\d+)
          update-major-version-in: |
            include/stringzilla/stringzilla.h:^#define STRINGZILLA_H_VERSION_MAJOR (\d+)
          update-minor-version-in: |
            include/stringzilla/stringzilla.h:^#define STRINGZILLA_H_VERSION_MINOR (\d+)
          update-patch-version-in: |
            include/stringzilla/stringzilla.h:^#define STRINGZILLA_H_VERSION_PATCH (\d+)
          dry-run: "true"

  test_ubuntu_gcc:
    name: Ubuntu (GCC 12) - ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-22.04, ubuntu-22.04-arm]
    env:
      CC: gcc-12
      CXX: g++-12

    steps:
      - uses: actions/checkout@v5
        with:
          submodules: recursive

      - name: Log hardware capabilities
        run: |
          echo "────────────────────────────────────────────────────────────────"
          echo "Hardware Capabilities"
          echo "────────────────────────────────────────────────────────────────"
          lscpu
          echo ""
          echo "CPU Info:"
          grep -E "model name|flags" /proc/cpuinfo | head -5 || true
          echo "────────────────────────────────────────────────────────────────"

        # C/C++
        # If the compilation fails, we want to log the compilation commands in addition to
        # the standard output.
      - name: Install dependencies
        run: |
          sudo apt update
          sudo apt install -y cmake build-essential gcc-12 g++-12

      - name: Build C/C++
        run: |
          cmake -B build_artifacts \
            -DCMAKE_BUILD_TYPE=RelWithDebInfo \
            -DCMAKE_EXPORT_COMPILE_COMMANDS=1 \
            -DSTRINGZILLA_BUILD_BENCHMARK=1 \
            -DSTRINGZILLA_BUILD_TEST=1

          cmake --build build_artifacts --config RelWithDebInfo > build_artifacts/logs.txt 2>&1 || {
            echo "Compilation failed. Here are the logs:"
            cat build_artifacts/logs.txt
            echo "The original compilation commands:"
            cat build_artifacts/compile_commands.json
            echo "GCC Version:"
            gcc-12 --version
            echo "G++ Version:"
            g++-12 --version
            exit 1
          }
      - name: Test C++
        run: build_artifacts/stringzilla_test_cpp20
      - name: Check stringzilla_bare is built correctly
        run: test -z "$(ldd build_artifacts/libstringzilla_bare.so | grep '.so')"
      - name: Build shared library for Go binding
        run: |
          cmake -B build_shared -DCMAKE_BUILD_TYPE=RelWithDebInfo -DSTRINGZILLA_BUILD_SHARED=1
          cmake --build build_shared --target stringzilla_shared --config RelWithDebInfo
      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ">=1.24"
      - name: Test Go binding
        working-directory: golang
        env:
          LD_LIBRARY_PATH: ${{ github.workspace }}/build_shared
        run: go test -v -tags no_sha256 # Skip SHA tests for GCC
      - name: Test on Real World Data
        run: |
          build_artifacts/stringzilla_bench_memory_cpp20 ${DATASET_PATH}     # for string copies and fills
          build_artifacts/stringzilla_bench_find_cpp20 ${DATASET_PATH}       # for substring search
          build_artifacts/stringzilla_bench_token_cpp20 ${DATASET_PATH}      # for hashing, equality comparisons, etc.
          build_artifacts/stringzilla_bench_sequence_cpp20 ${DATASET_PATH}   # for sorting arrays of strings
          build_artifacts/stringzilla_bench_container_cpp20 ${DATASET_PATH}  # for STL containers with string keys
        env:
          DATASET_PATH: ./README.md
        # Don't overload GitHub with our benchmarks.
        # The results in such an unstable environment will be meaningless anyway.
        if: 0

      - name: Test Parallel Algorithms on Real World Data
        run: |
          build_artifacts/stringzillas_bench_similarities_cpp20 ${DATASET_PATH} # for edit distances and alignment scores
          build_artifacts/stringzillas_bench_fingerprints_cpp20 ${DATASET_PATH} # for multi-needle search in many strings
        env:
          DATASET_PATH: ./README.md
        # Don't overload GitHub with our benchmarks.
        # The results in such an unstable environment will be meaningless anyway.
        if: 0

        # Python
      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5.6.0
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - name: Build Python
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-repeat numpy pyarrow
          python -m pip install .
      - name: Log Python capabilities
        run: |
          python - << 'PY'
          import platform
          import stringzilla as sz
          print("platform:", platform.platform())
          print("machine:", platform.machine(), "processor:", platform.processor())
          print("stringzilla.__capabilities__:", sz.__capabilities__)
          PY
      - name: Test Python
        run: python -X faulthandler -m pytest scripts/test_stringzilla.py -s -vv --maxfail=1 --full-trace

        # JavaScript
      - name: Set up Node.js
        uses: actions/setup-node@v5
        with:
          node-version: 20
      - name: Build and test JavaScript
        run: npm install && npm test

      # Rust
      - name: Test Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

  test_ubuntu_clang:
    name: Ubuntu (Clang 16) - ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-22.04, ubuntu-22.04-arm]
    env:
      CC: clang-16
      CXX: clang++-16

    steps:
      - uses: actions/checkout@v5
        with:
          submodules: recursive

      - name: Log hardware capabilities
        run: |
          echo "────────────────────────────────────────────────────────────────"
          echo "Hardware Capabilities"
          echo "────────────────────────────────────────────────────────────────"
          lscpu
          echo ""
          echo "CPU Info:"
          grep -E "model name|flags" /proc/cpuinfo | head -5 || true
          echo "────────────────────────────────────────────────────────────────"

        # C/C++
        # Clang 16 isn't available from default repos on Ubuntu 22.04, so we have to install it manually
      - name: Install dependencies
        run: |
          sudo apt update
          sudo apt install -y cmake build-essential libjemalloc-dev
          wget https://apt.llvm.org/llvm.sh
          chmod +x llvm.sh
          sudo ./llvm.sh 16

      - name: Build C/C++
        run: |
          cmake -B build_artifacts \
            -DCMAKE_BUILD_TYPE=RelWithDebInfo \
            -DCMAKE_EXPORT_COMPILE_COMMANDS=1 \
            -DSTRINGZILLA_BUILD_BENCHMARK=1 \
            -DSTRINGZILLA_BUILD_TEST=1

          cmake --build build_artifacts --config RelWithDebInfo > build_artifacts/logs.txt 2>&1 || {
            echo "Compilation failed. Here are the logs:"
            cat build_artifacts/logs.txt
            echo "The original compilation commands:"
            cat build_artifacts/compile_commands.json
            echo "Clang Version:"
            clang-16 --version
            echo "Clang++ Version:"
            clang++-16 --version
            exit 1
          }
      - name: Test C++
        run: build_artifacts/stringzilla_test_cpp20
      - name: Check stringzilla_bare is built correctly
        run: test -z "$(ldd build_artifacts/libstringzilla_bare.so | grep '.so')"
      - name: Build shared library for Go binding
        run: |
          cmake -B build_shared -DCMAKE_BUILD_TYPE=RelWithDebInfo -DSTRINGZILLA_BUILD_SHARED=1
          cmake --build build_shared --target stringzilla_shared --config RelWithDebInfo
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ">=1.24"
      - name: Test Go binding
        working-directory: golang
        env:
          LD_LIBRARY_PATH: ${{ github.workspace }}/build_shared
        run: go test -v
      - name: Test on Real World Data
        run: |
          build_artifacts/stringzilla_bench_find_cpp20 ${DATASET_PATH}      # for substring search
          build_artifacts/stringzilla_bench_token_cpp20 ${DATASET_PATH}     # for hashing, equality comparisons, etc.
          build_artifacts/stringzilla_bench_sequence_cpp20 ${DATASET_PATH}  # for sorting arrays of strings
          build_artifacts/stringzilla_bench_container_cpp20 ${DATASET_PATH} # for STL containers with string keys
        env:
          DATASET_PATH: ./README.md
        # Don't overload GitHub with our benchmarks.
        # The results in such an unstable environment will be meaningless anyway.
        if: 0

        # Python
      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5.6.0
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - name: Build Python
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-repeat numpy pyarrow
          python -m pip install .
      - name: Log Python capabilities
        run: |
          python - << 'PY'
          import platform
          import stringzilla as sz
          print("platform:", platform.platform())
          print("machine:", platform.machine(), "processor:", platform.processor())
          print("stringzilla.__capabilities__:", sz.__capabilities__)
          PY
      - name: Test Python
        run: python -X faulthandler -m pytest scripts/test_stringzilla.py -s -vv --maxfail=1 --full-trace

        # Rust
      - name: Test Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

        # Swift
        # Fails due to: https://github.com/swift-actions/setup-swift/issues/591
      # - name: Set up Swift ${{ env.SWIFT_VERSION }}
      #   uses: swift-actions/setup-swift@v2.3.0
      #   with:
      #     swift-version: ${{ env.SWIFT_VERSION }}
      # - name: Build Swift
      #   run: swift build -c release --static-swift-stdlib
      # - name: Test Swift
      #   run: swift test -c release

  test_ubuntu_cpus:
    name: Ubuntu (StringZillas-CPUs)
    runs-on: ubuntu-22.04
    env:
      CC: gcc-12
      CXX: g++-12

    steps:
      - uses: actions/checkout@v5
        with:
          submodules: recursive

      - name: Log hardware capabilities
        run: |
          echo "────────────────────────────────────────────────────────────────"
          echo "Hardware Capabilities"
          echo "────────────────────────────────────────────────────────────────"
          lscpu
          echo ""
          echo "CPU Info:"
          grep -E "model name|flags" /proc/cpuinfo | head -5 || true
          echo "────────────────────────────────────────────────────────────────"

        # C/C++
      - name: Install dependencies
        run: |
          sudo apt update
          sudo apt install -y cmake build-essential gcc-12 g++-12

      - name: Build C/C++
        run: |
          cmake -B build_artifacts \
            -DCMAKE_BUILD_TYPE=RelWithDebInfo \
            -DCMAKE_EXPORT_COMPILE_COMMANDS=1 \
            -DSTRINGZILLA_BUILD_BENCHMARK=1 \
            -DSTRINGZILLA_BUILD_TEST=1

          cmake --build build_artifacts --config RelWithDebInfo > build_artifacts/logs.txt 2>&1 || {
            echo "Compilation failed. Here are the logs:"
            cat build_artifacts/logs.txt
            echo "The original compilation commands:"
            cat build_artifacts/compile_commands.json
            echo "GCC Version:"
            gcc-12 --version
            echo "G++ Version:"
            g++-12 --version
            exit 1
          }
      - name: Test C++
        run: build_artifacts/stringzilla_test_cpp20
      - name: Check stringzilla_bare is built correctly
        run: test -z "$(ldd build_artifacts/libstringzilla_bare.so | grep '.so')"

        # Python StringZillas-CPUs
      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5.6.0
        with:
          python-version: ${{ env.PYTHON_VERSION }}
        # Ensure modern build backend is available for editable installs
      - name: Build Python StringZillas-CPUs
        run: |
          python -m pip install --upgrade pip
          pip install "setuptools>=64" wheel
          pip install pytest pytest-repeat numpy pyarrow affine-gaps
          SZ_TARGET=stringzilla pip install -e . --force-reinstall --no-build-isolation
          SZ_TARGET=stringzillas-cpus pip install -e . --force-reinstall --no-build-isolation
      - name: Log Python capabilities
        run: |
          python - << 'PY'
          import platform
          import stringzilla as sz
          import stringzillas as szs
          print("platform:", platform.platform())
          print("machine:", platform.machine(), "processor:", platform.processor())
          print("stringzilla.__capabilities__:", sz.__capabilities__)
          print("stringzillas.__capabilities__:", szs.__capabilities__)
          PY
      - name: Test Python StringZillas-CPUs
        run: python -X faulthandler -m pytest scripts/test_stringzillas.py -s -vv --maxfail=1 --full-trace

  test_ubuntu_cuda:
    name: Ubuntu (StringZillas-CUDA)
    runs-on: ubuntu-22.04
    env:
      CC: gcc-12
      CXX: g++-12

    steps:
      - uses: actions/checkout@v5
        with:
          submodules: recursive

        # Install CUDA Toolkit
      - name: Install CUDA Toolkit
        uses: Jimver/cuda-toolkit@v0.2.26
        with:
          cuda: "12.9.1"
          method: "network"

      - name: Log hardware capabilities
        run: |
          echo "────────────────────────────────────────────────────────────────"
          echo "Hardware Capabilities"
          echo "────────────────────────────────────────────────────────────────"
          lscpu
          echo ""
          echo "CPU Info:"
          grep -E "model name|flags" /proc/cpuinfo | head -5 || true
          echo ""
          echo "GPU Info:"
          nvcc --version 2>/dev/null || echo "nvcc not yet installed"
          nvidia-smi 2>/dev/null || echo "nvidia-smi not yet available"
          echo "────────────────────────────────────────────────────────────────"

        # C/C++
      - name: Install dependencies
        run: |
          sudo apt update
          sudo apt install -y cmake build-essential gcc-12 g++-12

      - name: Build C/C++ with CUDA
        run: |
          # Note: Using Release build type instead of RelWithDebInfo
          # Optimized debugging not supported in CUDA and results in PTXAS fatal errors
          cmake -B build_artifacts \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_EXPORT_COMPILE_COMMANDS=1 \
            -DSTRINGZILLA_BUILD_BENCHMARK=1 \
            -DSTRINGZILLA_BUILD_TEST=1

          cmake --build build_artifacts --config Release > build_artifacts/logs.txt 2>&1 || {
            echo "Compilation failed. Here are the logs:"
            cat build_artifacts/logs.txt
            echo "The original compilation commands:"
            cat build_artifacts/compile_commands.json
            echo "CUDA Version:"
            nvcc --version
            echo "GCC Version:"
            gcc-12 --version
            echo "G++ Version:"
            g++-12 --version
            exit 1
          }
      - name: Test C++
        run: build_artifacts/stringzilla_test_cpp20
      - name: Check stringzilla_bare is built correctly
        run: test -z "$(ldd build_artifacts/libstringzilla_bare.so | grep '.so')"

        # Python StringZillas-CUDA
      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5.6.0
        with:
          python-version: ${{ env.PYTHON_VERSION }}
        # Ensure modern build backend is available for editable installs
      - name: Build Python StringZillas-CUDA
        run: |
          python -m pip install --upgrade pip
          pip install "setuptools>=64" wheel
          pip install pytest pytest-repeat numpy pyarrow wheel affine-gaps
          SZ_TARGET=stringzilla pip install -e . --force-reinstall --no-build-isolation
          SZ_TARGET=stringzillas-cuda pip install -e . --force-reinstall --no-build-isolation
      - name: Log Python capabilities
        run: |
          python - << 'PY'
          import platform
          import stringzilla as sz
          import stringzillas as szs
          print("platform:", platform.platform())
          print("machine:", platform.machine(), "processor:", platform.processor())
          print("stringzilla.__capabilities__:", sz.__capabilities__)
          print("stringzillas.__capabilities__:", szs.__capabilities__)
          PY
      - name: Test Python StringZillas-CUDA
        run: python -X faulthandler -m pytest scripts/test_stringzillas.py -s -vv --maxfail=1 --full-trace

  # Temporary workaround to run Swift tests on Linux
  # Based on: https://github.com/swift-actions/setup-swift/issues/591#issuecomment-1685710678
  test_ubuntu_swift:
    name: Swift on Linux
    runs-on: ubuntu-22.04
    container: swift:latest
    steps:
      - uses: actions/checkout@v5
        with:
          submodules: recursive

      - name: Log hardware capabilities
        run: |
          echo "────────────────────────────────────────────────────────────────"
          echo "Hardware Capabilities"
          echo "────────────────────────────────────────────────────────────────"
          lscpu || true
          echo ""
          echo "CPU Info:"
          grep -E "model name|flags" /proc/cpuinfo | head -5 || true
          echo "────────────────────────────────────────────────────────────────"

      - name: Test Swift
        run: swift test

  test_cross_x86_to_arm:
    name: Cross Compile (x86_64 → ARM64)
    runs-on: ubuntu-22.04
    env:
      CC: clang-16
      CXX: clang++-16
      AR: llvm-ar-16
      NM: llvm-nm-16
      RANLIB: llvm-ranlib-16

    steps:
      - uses: actions/checkout@v5
        with:
          submodules: recursive

      - name: Log hardware capabilities
        run: |
          echo "────────────────────────────────────────────────────────────────"
          echo "Cross-Compilation: x86_64 → aarch64"
          echo "────────────────────────────────────────────────────────────────"
          lscpu
          echo ""
          echo "CPU Info:"
          grep -E "model name|flags" /proc/cpuinfo | head -5 || true
          echo "────────────────────────────────────────────────────────────────"

      - name: Install cross-compilation toolchain
        run: |
          sudo apt-get update
          sudo apt-get install -y make build-essential crossbuild-essential-arm64
          wget https://apt.llvm.org/llvm.sh
          chmod +x llvm.sh
          sudo ./llvm.sh 16

      - name: Build C/C++ for ARM64
        run: |
          # Configure CMake for cross-compilation
          # We skip compiler tests because the linker can't execute ARM64 binaries during configuration
          # We provide explicit properties that CMake would normally detect automatically
          cmake -B build_artifacts \
            -DCMAKE_C_COMPILER_WORKS=1 \
            -DCMAKE_CXX_COMPILER_WORKS=1 \
            -DCMAKE_SIZEOF_VOID_P=8 \
            -DCMAKE_THREAD_LIBS_INIT=-lpthread \
            -DCMAKE_HAVE_THREADS_LIBRARY=1 \
            -DCMAKE_BUILD_TYPE=RelWithDebInfo \
            -DCMAKE_EXPORT_COMPILE_COMMANDS=1 \
            -DCMAKE_C_COMPILER_TARGET=aarch64-linux-gnu \
            -DCMAKE_CXX_COMPILER_TARGET=aarch64-linux-gnu \
            -DCMAKE_SYSROOT=/usr/aarch64-linux-gnu \
            -DCMAKE_SYSTEM_NAME=Linux \
            -DCMAKE_SYSTEM_PROCESSOR=aarch64 \
            -DCMAKE_FIND_ROOT_PATH=/usr/aarch64-linux-gnu \
            -DCMAKE_FIND_ROOT_PATH_MODE_PROGRAM=NEVER \
            -DCMAKE_FIND_ROOT_PATH_MODE_LIBRARY=ONLY \
            -DCMAKE_FIND_ROOT_PATH_MODE_INCLUDE=ONLY \
            -DSTRINGZILLA_BUILD_SHARED=1 \
            -DSTRINGZILLA_BUILD_BENCHMARK=1 \
            -DSTRINGZILLA_BUILD_TEST=1

          cmake --build build_artifacts --config RelWithDebInfo

      - name: Verify ARM64 binaries
        run: |
          # We can't run ARM64 binaries on x86_64, but we can verify they exist and are ARM64
          test -e build_artifacts/libstringzilla_bare.so
          test -e build_artifacts/libstringzilla_shared.so
          test -e build_artifacts/stringzilla_test_cpp20
          file build_artifacts/stringzilla_test_cpp20 | grep -q "aarch64"
          echo "✓ ARM64 binaries built successfully"

  test_cross_arm_to_x86:
    name: Cross Compile (ARM64 → x86_64)
    runs-on: ubuntu-22.04-arm
    env:
      CC: clang-16
      CXX: clang++-16
      AR: llvm-ar-16
      NM: llvm-nm-16
      RANLIB: llvm-ranlib-16

    steps:
      - uses: actions/checkout@v5
        with:
          submodules: recursive

      - name: Log hardware capabilities
        run: |
          echo "────────────────────────────────────────────────────────────────"
          echo "Cross-Compilation: aarch64 → x86_64"
          echo "────────────────────────────────────────────────────────────────"
          lscpu
          echo ""
          echo "CPU Info:"
          grep -E "model name|flags" /proc/cpuinfo | head -5 || true
          echo "────────────────────────────────────────────────────────────────"

      - name: Install cross-compilation toolchain
        run: |
          sudo apt-get update
          sudo apt-get install -y make build-essential crossbuild-essential-amd64
          wget https://apt.llvm.org/llvm.sh
          chmod +x llvm.sh
          sudo ./llvm.sh 16

      - name: Build C/C++ for x86_64
        run: |
          # Configure CMake for cross-compilation
          # We skip compiler tests because the linker can't execute x86_64 binaries during configuration
          # We provide explicit properties that CMake would normally detect automatically
          cmake -B build_artifacts \
            -DCMAKE_C_COMPILER_WORKS=1 \
            -DCMAKE_CXX_COMPILER_WORKS=1 \
            -DCMAKE_SIZEOF_VOID_P=8 \
            -DCMAKE_THREAD_LIBS_INIT=-lpthread \
            -DCMAKE_HAVE_THREADS_LIBRARY=1 \
            -DCMAKE_BUILD_TYPE=RelWithDebInfo \
            -DCMAKE_EXPORT_COMPILE_COMMANDS=1 \
            -DCMAKE_C_COMPILER_TARGET=x86_64-linux-gnu \
            -DCMAKE_CXX_COMPILER_TARGET=x86_64-linux-gnu \
            -DCMAKE_SYSROOT=/usr/x86_64-linux-gnu \
            -DCMAKE_SYSTEM_NAME=Linux \
            -DCMAKE_SYSTEM_PROCESSOR=x86_64 \
            -DCMAKE_FIND_ROOT_PATH=/usr/x86_64-linux-gnu \
            -DCMAKE_FIND_ROOT_PATH_MODE_PROGRAM=NEVER \
            -DCMAKE_FIND_ROOT_PATH_MODE_LIBRARY=ONLY \
            -DCMAKE_FIND_ROOT_PATH_MODE_INCLUDE=ONLY \
            -DSTRINGZILLA_BUILD_SHARED=1 \
            -DSTRINGZILLA_BUILD_BENCHMARK=1 \
            -DSTRINGZILLA_BUILD_TEST=1

          cmake --build build_artifacts --config RelWithDebInfo

      - name: Verify x86_64 binaries
        run: |
          # We can't run x86_64 binaries on ARM64, but we can verify they exist and are x86_64
          test -e build_artifacts/libstringzilla_bare.so
          test -e build_artifacts/libstringzilla_shared.so
          test -e build_artifacts/stringzilla_test_cpp20
          file build_artifacts/stringzilla_test_cpp20 | grep -q "x86-64"
          echo "✓ x86_64 binaries built successfully"

  test_macos:
    name: MacOS
    runs-on: macos-14

    steps:
      - uses: actions/checkout@v5
        with:
          submodules: recursive

      - name: Log hardware capabilities
        run: |
          echo "────────────────────────────────────────────────────────────────"
          echo "Hardware Capabilities"
          echo "────────────────────────────────────────────────────────────────"
          sysctl -a | grep machdep.cpu || true
          echo ""
          echo "System Info:"
          system_profiler SPHardwareDataType || true
          echo "────────────────────────────────────────────────────────────────"

        # C/C++
      - name: Install dependencies
        run: |
          brew update
          brew reinstall cmake
      - name: Build C/C++
        run: |
          cmake -B build_artifacts \
            -DCMAKE_BUILD_TYPE=RelWithDebInfo \
            -DCMAKE_EXPORT_COMPILE_COMMANDS=1 \
            -DSTRINGZILLA_BUILD_BENCHMARK=1 \
            -DSTRINGZILLA_BUILD_TEST=1
          cmake --build build_artifacts --config RelWithDebInfo
      - name: Test C++
        run: build_artifacts/stringzilla_test_cpp17
      - name: Test on Real World Data
        run: |
          build_artifacts/stringzilla_bench_find_cpp20 ${DATASET_PATH}      # for substring search
          build_artifacts/stringzilla_bench_token_cpp20 ${DATASET_PATH}     # for hashing, equality comparisons, etc.
          build_artifacts/stringzilla_bench_sequence_cpp20 ${DATASET_PATH}  # for sorting arrays of strings
          build_artifacts/stringzilla_bench_container_cpp20 ${DATASET_PATH} # for STL containers with string keys
        env:
          DATASET_PATH: ./README.md
        # Don't overload GitHub with our benchmarks.
        # The results in such an unstable environment will be meaningless anyway.
        if: 0

        # Python
      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5.6.0
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - name: Build Python
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-repeat numpy pyarrow
          python -m pip install .
        env:
          MACOSX_DEPLOYMENT_TARGET: "11.0"
      - name: Test Python
        run: python -X faulthandler -m pytest scripts/test_stringzilla.py -s -vv --maxfail=1 --full-trace

        # Swift
      - name: Set up Swift ${{ env.SWIFT_VERSION }}
        uses: swift-actions/setup-swift@v2.3.0
        with:
          swift-version: ${{ env.SWIFT_VERSION }}
      - name: Build Swift
        run: swift build
      - name: Test Swift
        run: swift test

        # Rust
      - name: Test Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

  test_windows:
    name: Windows - ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-2022
            arch: x64
          - os: windows-11-arm
            arch: arm64
    steps:
      - uses: actions/checkout@v5
        with:
          submodules: recursive
      - uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: ${{ matrix.arch }}

      - name: Log hardware capabilities
        shell: powershell
        run: |
          Write-Host "────────────────────────────────────────────────────────────────"
          Write-Host "Hardware Capabilities"
          Write-Host "────────────────────────────────────────────────────────────────"
          Get-CimInstance -ClassName Win32_Processor | Select-Object Name, NumberOfCores, NumberOfLogicalProcessors, MaxClockSpeed | Format-List
          Write-Host "────────────────────────────────────────────────────────────────"

      - name: Build C/C++
        shell: cmd
        run: |
          cmake -GNinja -B build_artifacts ^
            -DCMAKE_BUILD_TYPE=RelWithDebInfo ^
            -DCMAKE_EXPORT_COMPILE_COMMANDS=1 ^
            -DSTRINGZILLA_BUILD_BENCHMARK=1 ^
            -DSTRINGZILLA_BUILD_TEST=1

          cmake --build build_artifacts --config RelWithDebInfo > build_artifacts/logs.txt 2>&1 || (
            echo "Compilation failed. Here are the logs:"
            type build_artifacts\logs.txt
            echo "The original compilation commands:"
            type build_artifacts\compile_commands.json
            exit 1
          )
      - name: Test C++
        run: .\build_artifacts\stringzilla_test_cpp20.exe
      - name: Check stringzilla_bare is built correctly
        shell: cmd
        run: dumpbin /nologo /dependents .\build_artifacts\stringzilla_bare.dll | findstr /r "[a-zA-Z0-9]\.dll" | findstr /r /v "KERNEL32.dll stringzilla" && exit /b 1 || exit /b 0
      - name: Test on Real World Data
        run: |
          .\build_artifacts\stringzilla_bench_find_cpp20.exe ${DATASET_PATH}      # for substring search
          .\build_artifacts\stringzilla_bench_token_cpp20.exe ${DATASET_PATH}     # for hashing, equality comparisons, etc.
          .\build_artifacts\stringzilla_bench_sequence_cpp20.exe ${DATASET_PATH}  # for sorting arrays of strings
          .\build_artifacts\stringzilla_bench_container_cpp20.exe ${DATASET_PATH} # for STL containers with string keys
        env:
          DATASET_PATH: ./README.md
        # Don't overload GitHub with our benchmarks.
        # The results in such an unstable environment will be meaningless anyway.
        if: 0

        # Python
      - name: Set up Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5.6.0
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      - name: Build Python
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-repeat numpy
          python -m pip install .
      - name: Test Python
        run: python -X faulthandler -m pytest scripts/test_stringzilla.py -s -vv --maxfail=1 --full-trace

  test_alpine:
    name: Alpine Linux
    runs-on: ubuntu-24.04
    container:
      image: alpine:latest
      options: --privileged # If needed for certain Docker operations
    steps:
      - name: Install Git for checkout
        run: |
          apk add --no-cache git openssh ca-certificates
          git --version
      - name: Log Alpine and Git versions
        run: |
          echo "Alpine: $(cat /etc/alpine-release 2>/dev/null || echo 'unknown')"
          git --version || echo "git not installed"
      - uses: actions/checkout@v5
        with:
          submodules: recursive

      - name: Log hardware capabilities
        run: |
          echo "────────────────────────────────────────────────────────────────"
          echo "Hardware Capabilities"
          echo "────────────────────────────────────────────────────────────────"
          lscpu || true
          echo ""
          echo "CPU Info:"
          grep -E "model name|flags" /proc/cpuinfo | head -5 || true
          echo "────────────────────────────────────────────────────────────────"

        # C/C++
      - name: Build C/C++
        run: |
          apk add --update make cmake g++ gcc
          cmake -B build_artifacts \
            -DCMAKE_BUILD_TYPE=RelWithDebInfo \
            -DCMAKE_EXPORT_COMPILE_COMMANDS=1 \
            -DSTRINGZILLA_BUILD_BENCHMARK=1 \
            -DSTRINGZILLA_BUILD_TEST=1
          cmake --build build_artifacts --config RelWithDebInfo
      - name: Test C++
        run: build_artifacts/stringzilla_test_cpp20
      - name: Check stringzilla_bare is built correctly
        run: test -z "$(ldd build_artifacts/libstringzilla_bare.so | grep '.so' | grep '=>')"

        # Python
      - name: Build Python
        run: |
          apk add python3 py3-pip python3-dev
          pip install --break-system-packages pytest pytest-repeat
          pip install --break-system-packages .
      - name: Test Python
        run: pytest scripts/test_stringzilla.py -s -x

        # Rust
      - name: Test Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

  build_wheels:
    name: Build Python ${{ matrix.python-version }} for ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    needs:
      [
        test_ubuntu_gcc,
        test_ubuntu_clang,
        test_macos,
        test_windows,
        test_cross_x86_to_arm,
        test_cross_arm_to_x86,
      ]
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-24.04, macos-13, windows-2022]
        python-version: ["38", "39", "310", "311", "312", "313"]
    steps:
      - uses: actions/checkout@v5
        with:
          submodules: recursive
      - name: Set up Python
        uses: actions/setup-python@v5.6.0
        with:
          python-version: 3.x

        # We only need QEMU for Linux builds
      - name: Setup QEMU
        if: matrix.os == 'ubuntu-24.04'
        uses: docker/setup-qemu-action@v3
      - name: Install cibuildwheel
        run: python -m pip install cibuildwheel==2.21.3
      - name: Build wheels
        run: cibuildwheel --output-dir wheelhouse
        env:
          CIBW_BUILD: cp${{ matrix.python-version }}-*
          CIBW_ENVIRONMENT_LINUX: SZ_IS_QEMU_=1 # When emulating this will disable some tricky SIMD instructions
